package com.company;

import com.aliyuncs.DefaultAcsClient;
import com.aliyuncs.IAcsClient;
import com.aliyuncs.exceptions.ClientException;
import com.aliyuncs.http.ProtocolType;
import com.aliyuncs.profile.DefaultProfile;
import com.aliyuncs.regions.ProductDomain;
import com.aliyuncs.rtc.model.v20180111.CreateChannelRequest;
import com.aliyuncs.rtc.model.v20180111.CreateChannelResponse;
import com.sun.net.httpserver.Headers;
import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.PosixParser;
import org.json.JSONArray;
import org.json.JSONObject;

import javax.xml.bind.DatatypeConverter;
import java.io.IOException;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.*;

public class App {
    // Parsed from CLI.
    private int listen;
    private String appID;
    private String regionID = "cn-hangzhou";
    private String endpoint = "rtc.aliyuncs.com";
    private String accessKeyID;
    private String accessKeySecret;
    private String gslb;
    // Generated by AppServer.
    private String session;
    private String userID;
    private String token;

    // Cached channel.
    private HashMap<String, ChannelAuth> channels;

    class ChannelAuth {
        public String appID;
        public String channelID;
        public String nonce;
        public Integer timestamp;
        public String channelKey;
        public Boolean recovered;
        public String requestID;
    }

    public static String createToken(
            String appId, String userId, String channelId,
            String channelKey, String nonce, Integer timestamp,
            String sessionId
    ) throws NoSuchAlgorithmException {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        digest.update(channelId.getBytes());
        digest.update(channelKey.getBytes());
        digest.update(appId.getBytes());
        digest.update(userId.getBytes());
        digest.update(sessionId.getBytes());
        digest.update(nonce.getBytes());
        digest.update(Long.toString(timestamp).getBytes());

        String token = DatatypeConverter
                .printHexBinary(digest.digest())
                .toLowerCase();
        return token;
    }

    private ChannelAuth recoverForError(ClientException ex, String appID, String channelID)
            throws ClientException
    {
        boolean fatal = false;
        if (ex != null) {
            String code = ex.getErrCode();
            if (code.equalsIgnoreCase("IllegalOperationApp")) {
                fatal = true;
            } else if (code.startsWith("InvalidAccessKeyId")) {
                fatal = true;
            } else if (code.equalsIgnoreCase("SignatureDoesNotMatch")) {
                fatal = true;
            }
        }

        if (fatal) {
            throw ex;
        }

        String recover = String.format("RCV-%s", UUID.randomUUID().toString());
        ChannelAuth auth = new ChannelAuth();
        auth.appID = appID;
        auth.channelID = channelID;
        auth.nonce = recover;
        auth.timestamp = 0;
        auth.channelKey = recover;
        auth.recovered = true;
        auth.requestID = ex.getRequestId();

        System.out.printf("Recover from error:\n");
        ex.printStackTrace();
        return auth;
    }

    private ChannelAuth createChannel(String appID, String channelID) throws ClientException {
        try {
            DefaultProfile profile = DefaultProfile.getProfile(regionID, accessKeyID, accessKeySecret);
            DefaultAcsClient client = new DefaultAcsClient(profile);

            CreateChannelRequest request = new CreateChannelRequest();
            request.setAppId(appID);
            request.setChannelId(channelID);

            // Strongly recomment to set the RTC endpoint,
            // because the exception is not the "right" one if not set.
            // For example, if access-key-id is invalid:
            //      1. if endpoint is set, exception is InvalidAccessKeyId.NotFound
            //      2. if endpoint isn't set, exception is SDK.InvalidRegionId
            // that's caused by query endpoint failed.
            // @remark SDk will cache endpoints, however it will query endpoint for the first
            //      time, so it's good for performance to set the endpoint.
            request.setEndpoint(endpoint);

            // Use HTTP, x3 times faster than HTTPS.
            request.setProtocol(ProtocolType.HTTP);

            client.setAutoRetry(true);
            client.setMaxRetryNumber(3);
            request.setConnectTimeout(2000);
            request.setReadTimeout(3000);

            CreateChannelResponse response = client.getAcsResponse(request);

            ChannelAuth auth = new ChannelAuth();
            auth.appID = appID;
            auth.channelID = channelID;
            auth.nonce = response.getNonce();
            auth.timestamp = response.getTimestamp();
            auth.channelKey = response.getChannelKey();
            auth.recovered = false;
            auth.requestID = response.getRequestId();

            return auth;
        } catch (ClientException ex) {
            return recoverForError(ex, appID, channelID);
        }
    }

    private void httpWrite(HttpExchange he, int code, String response) throws IOException {
        OutputStream os = he.getResponseBody();
        he.sendResponseHeaders(code, response.length());
        os.write(response.getBytes());
        os.close();
    }

    class LoginHandler implements HttpHandler {
        public void handle(HttpExchange he) throws IOException {
            if (he.getRequestHeaders().containsKey("Origin")) {
                Headers headers = he.getResponseHeaders();
                headers.set("Access-Control-Allow-Origin", "*");
                headers.set("Access-Control-Allow-Methods", "GET,POST,HEAD,PUT,DELETE,OPTIONS");
                headers.set("Access-Control-Expose-Headers", "Server,Range,Content-Length,Content-Range");
                headers.set("Access-Control-Allow-Headers", "Origin,Range,Accept-Encoding,Referer,Cache-Control,X-Proxy-Authorization,X-Requested-With,Content-Type");
            }

            if (he.getRequestMethod().equalsIgnoreCase("OPTIONS")) {
                httpWrite(he, 200, "");
                return;
            }

            Map<String, String> query = new HashMap<String, String>();
            for (String param : he.getRequestURI().getQuery().split("&")) {
                String[] entry = param.split("=");
                if (entry.length > 1) {
                    query.put(entry[0], entry[1]);
                }else{
                    query.put(entry[0], "");
                }
            }

            String channelID = query.get("room");
            String user = query.get("user");
            String channelUrl = String.format("%s/%s", appID, channelID);

            // Create channel if not exists.
            ChannelAuth auth = null;
            Date starttime = new Date();
            if (!channels.containsKey(channelUrl)) {
                try {
                    auth = createChannel(appID, channelID);
                    System.out.printf("CreateChannel requestID=%s, cost=%dms, url=%s, nonce=%s, timestamp=%d, channelKey=%s, recovered=%b\n",
                            auth.requestID, new Date().getTime() - starttime.getTime(), channelUrl, auth.nonce, auth.timestamp, auth.channelKey, auth.recovered);

                    // If recovered from error, we should never cache it,
                    // and we should try to request again next time.
                    if (!auth.recovered) {
                        channels.put(channelUrl, auth);
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    httpWrite(he, 500, e.toString());
                    return;
                }
            } else {
                auth = channels.get(channelUrl);
            }

            userID = UUID.randomUUID().toString();
            session = UUID.randomUUID().toString();
            try {
                token = createToken(appID, userID, channelID, auth.channelKey, auth.nonce, auth.timestamp, session);
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
                httpWrite(he, 500, e.getMessage());
                return;
            }
            System.out.printf("Sign cost=%dms, user=%s, userID=%s, session=%s, token=%s, channelKey=%s, nonce=%s, timestamp=%d, recovered=%b\n",
                    new Date().getTime() - starttime.getTime(), user, userID, session, token, auth.channelKey, auth.nonce, auth.timestamp, auth.recovered);

            String username = String.format("%s?appid=%s&session=%s&channel=%s&nonce=%s&timestamp=%d",
                    userID, appID, session, channelID, auth.nonce, auth.timestamp);
            JSONObject response = new JSONObject()
                    .put("code", 0)
                    .put("data", new JSONObject()
                            .put("appid", appID)
                            .put("userid", userID)
                            .put("gslb", new JSONArray().put(gslb))
                            .put("session", session)
                            .put("token", token)
                            .put("nonce", auth.nonce)
                            .put("timestamp", auth.timestamp)
                            .put("turn", new JSONObject()
                                    .put("username", username)
                                    .put("password", token)
                            ));
            he.getResponseHeaders().set("Content-Type", "application/json");
            httpWrite(he, 200, response.toString());
        }
    }

    public App() {
        channels = new HashMap<String, ChannelAuth>();
    }

    public void run(String[] args) throws Exception {
        Options options = new Options();
        options.addOption(new Option("l", "listen", true, "listen port"));
        options.addOption(new Option("a", "appid", true, "the id of app"));
        options.addOption(new Option("i", "access-key-id", true, "the id of access key"));
        options.addOption(new Option("k", "access-key-secret", true, "the secret of access key"));
        options.addOption(new Option("g", "gslb", true, "the url of gslb"));
        CommandLine cli = new PosixParser().parse(options, args);
        if (!cli.hasOption("listen")) {
            throw new Exception("no listen");
        }
        if (!cli.hasOption("appid")) {
            throw new Exception("no appid");
        }
        if (!cli.hasOption("access-key-id")) {
            throw new Exception("no access-key-id");
        }
        if (!cli.hasOption("access-key-secret")) {
            throw new Exception("no access-key-secret");
        }
        if (!cli.hasOption("gslb")) {
            throw new Exception("no gslb");
        }

        listen = Integer.parseInt(cli.getOptionValue("listen"));
        appID = cli.getOptionValue("appid");
        accessKeyID = cli.getOptionValue("access-key-id");
        accessKeySecret = cli.getOptionValue("access-key-secret");
        gslb = cli.getOptionValue("gslb");
        System.out.printf("Server listen=%d, appid=%s, akID=%s, akSecret=%s, gslb=%s, region=%s, endpoint=%s\n",
                listen, appID, accessKeyID, accessKeySecret, gslb, regionID, endpoint);

        HttpServer server = HttpServer.create(new InetSocketAddress(listen), 0);
        server.createContext("/app/v1/login", new LoginHandler());
        server.start();
    }

    public static void main(String[] args) {
        try {
            new App().run(args);
        } catch (Exception e) {
            System.out.println(e);
        }
    }
}
